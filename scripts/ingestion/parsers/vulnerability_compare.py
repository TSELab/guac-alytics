import requests
import json
from bs4 import BeautifulSoup
from datetime import date
import sqlite3
from constants import VULNERABILITY_DATA, NIST_URL, DB_LOC, VULNERABILITY_URL

# Function to fetch data from the URL
def fetch_data():
    response = requests.get(VULNERABILITY_URL)
    if response.status_code == 200:
        return response.json()
    else:
        print("Failed to fetch data from the URL.")
        return None

# Function to save data to a JSON file
def save_to_json(data):
    year=date.today().year
    mon=date.today().month
    day=date.today().day
    f=VULNERABILITY_DATA.format(year,mon,day)
    with open(f, "w") as file:
        json.dump(data, file)
    file.close()
    return file

def parse_vulnerability_data(vulnerability_id):
    url = f"{NIST_URL}{vulnerability_id}"
    
    response = requests.get(url)
    if response.status_code == 200:
        soup = BeautifulSoup(response.content, 'html.parser')
        
        # Find and extract the published date
        published_date_element = soup.find('span', {'data-testid': 'vuln-published-on'})
        published_date = published_date_element.text.strip() if published_date_element else None
        
        # Find and extract the last modified date
        last_modified_date_element = soup.find('span', {'data-testid': 'vuln-last-modified-on'})
        last_modified_date = last_modified_date_element.text.strip() if last_modified_date_element else None
        
        return published_date, last_modified_date
    
    return None, None

def insert_records(cur,name,cve,description,published_date, last_modified_date,debianbug,scope,releases):
    INSERT_RECS = '''INSERT OR IGNORE INTO vulnerability_table (source_id,package,vulnerability,description,published_date, last_modified_date,debianbug,scope,releases) VALUES (?,?,?,?,?,?,?,?,?)'''
    cur.execute('''delete from vulnerability_table''')
    cur.execute('''select source_id,source_name from source_table where source_name ='{}' limit 1'''.format(name))
    id = cur.fetchone()
    if id:
        cur.execute(INSERT_RECS, (id[0],name,cve,description,published_date, last_modified_date,debianbug,scope,str(releases))) 
    else: 
        cur.execute(INSERT_RECS, ('Null',name,cve,description,published_date, last_modified_date,debianbug,scope,str(releases)))   


def parser(file):
    con = sqlite3.connect(DB_LOC)
    # Check if the file exists locally, if not, download it
    with open (file, 'r') as f:
        parsed_data = json.load(f)

    for name, vulnerability in parsed_data.items():
        for cve, info in vulnerability.items():
            if 'description' in info:
                description = info['description']
            else:
                description="None"
            if 'debianbug' in info:
                debianbug = info['debianbug']
            else:
                debianbug="None"
            if 'scope' in info:
                scope = info['scope']
            else:
                scope="None"
            releases = info['releases']
            # print(f"{name}|{cve}|{description}|{debianbug}|{scope}|{releases}")
            cur = con.cursor()
            # to insert records into the table
            published_date, last_modified_date = parse_vulnerability_data(cve)
            insert_records(cur,name,cve,description,published_date, last_modified_date,debianbug,scope,releases) 
            con.commit()
        
    con.close()

# Main function to run the process
def main():
    data = fetch_data()
    if data:
        print(date.today())
        file_obj = save_to_json(data)
        file = file_obj.name
        parser(file)
        print("Data Updated.")

# Run the process
if __name__ == "__main__":
    main()
